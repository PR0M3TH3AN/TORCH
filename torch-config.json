{
  "nostrLock": {
    "namespace": "torch",
    "relays": [
      "wss://relay.damus.io",
      "wss://nos.lol",
      "wss://relay.primal.net"
    ],
    "ttlSeconds": 7200,
    "queryTimeoutMs": 15000
  },
  "dashboard": {
    "defaultCadenceView": "all",
    "defaultStatusView": "all"
  },
  "scheduler": {
    "firstPromptByCadence": {
      "daily": "scheduler-update-agent",
      "weekly": "bug-reproducer-agent"
    },
    "handoffCommandByCadence": {
      "daily": "node scripts/agent/run-selected-prompt.mjs",
      "weekly": "node scripts/agent/run-selected-prompt.mjs"
    },
    "memoryPolicyByCadence": {
      "daily": {
        "mode": "required",
        "retrieveCommand": "set -euo pipefail; node --input-type=module -e \"import { ingestEvents, getRelevantMemories } from './src/services/memory/index.js'; import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'; const fallbackCadence='daily'; const cadence=process.env.SCHEDULER_CADENCE || fallbackCadence; const agentId=process.env.SCHEDULER_AGENT || ('scheduler-memory-' + cadence); const promptPath=process.env.SCHEDULER_PROMPT_PATH || ''; const runId=(process.env.SCHEDULER_RUN_ID || process.env.SCHEDULER_SESSION_ID || process.env.RUN_ID || ('session-' + Date.now().toString(36))); const promptRaw=promptPath ? readFileSync(promptPath, 'utf8') : ''; const promptLines=promptRaw.split(/\\r?\\n/).map((line)=>line.trim()).filter(Boolean); const promptIntent=promptLines.find((line)=>line.startsWith('#') || line.toLowerCase().startsWith('goal')) || promptLines[0] || 'scheduler memory retrieval'; const query=['scheduler', cadence, 'agent', agentId, 'intent', promptIntent.replace(/^#+\\s*/, '')].join(' | '); const timestamp=Date.now(); const events=[{ agent_id: agentId, content: 'Memory retrieval seed for ' + cadence + ' :: ' + promptIntent, timestamp, tags:['scheduler', cadence, 'retrieve'], metadata:{ session_id:runId, source:'scheduler-retrieve', importance:0.4, prompt_path:promptPath } }]; const ingested=await ingestEvents(events,{ agent_id: agentId }); const retrieved=await getRelevantMemories({ agent_id: agentId, query, k: 5 }); const sessionDir='.scheduler-memory/' + runId; const latestDir='.scheduler-memory/latest/' + cadence; mkdirSync(sessionDir,{ recursive:true }); mkdirSync(latestDir,{ recursive:true }); const artifact={ cadence, operation:'retrieve', runId, servicePath:'src/services/memory/index.js#getRelevantMemories', inputs:{ agentId, promptPath, promptIntent, query, events:events.length }, outputs:{ ingestedCount:ingested.length, retrievedCount:retrieved.length }, status:'ok' }; writeFileSync(sessionDir + '/retrieve.json', JSON.stringify(artifact, null, 2)); writeFileSync(sessionDir + '/retrieve.ok', 'MEMORY_RETRIEVED\\n'); writeFileSync(latestDir + '/retrieve.ok', 'MEMORY_RETRIEVED\\n');\"; echo MEMORY_RETRIEVED",
        "storeCommand": "set -euo pipefail; node --input-type=module -e \"import { ingestEvents } from './src/services/memory/index.js'; import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'; const fallbackCadence='daily'; const cadence=process.env.SCHEDULER_CADENCE || fallbackCadence; const agentId=process.env.SCHEDULER_AGENT || ('scheduler-memory-' + cadence); const promptPath=process.env.SCHEDULER_PROMPT_PATH || ''; const runId=(process.env.SCHEDULER_RUN_ID || process.env.SCHEDULER_SESSION_ID || process.env.RUN_ID || ('session-' + Date.now().toString(36))); const promptRaw=promptPath ? readFileSync(promptPath, 'utf8') : ''; const promptLines=promptRaw.split(/\\r?\\n/).map((line)=>line.trim()).filter(Boolean); const promptIntent=promptLines.find((line)=>line.startsWith('#') || line.toLowerCase().startsWith('goal')) || promptLines[0] || 'scheduler memory store'; const baseTs=Date.now(); const events=[{ agent_id: agentId, content: 'Store memory event A for ' + cadence + ' :: ' + promptIntent, timestamp: baseTs, tags:['scheduler', cadence, 'store'], metadata:{ session_id:runId, source:'scheduler-store', importance:0.55, prompt_path:promptPath } },{ agent_id: agentId, content: 'Store memory event B for ' + cadence + ' :: ' + promptIntent, timestamp: baseTs + 1, tags:['scheduler', cadence, 'store'], metadata:{ session_id:runId, source:'scheduler-store', importance:0.55, prompt_path:promptPath } }]; const stored=await ingestEvents(events,{ agent_id: agentId }); const sessionDir='.scheduler-memory/' + runId; const latestDir='.scheduler-memory/latest/' + cadence; mkdirSync(sessionDir,{ recursive:true }); mkdirSync(latestDir,{ recursive:true }); const artifact={ cadence, operation:'store', runId, servicePath:'src/services/memory/index.js#ingestEvents', inputs:{ agentId, promptPath, promptIntent, events:events.length }, outputs:{ storedCount:stored.length, summaries:stored.map((m)=>m.summary) }, status:'ok' }; writeFileSync(sessionDir + '/store.json', JSON.stringify(artifact, null, 2)); writeFileSync(sessionDir + '/store.ok', 'MEMORY_STORED\\n'); writeFileSync(latestDir + '/store.ok', 'MEMORY_STORED\\n');\"; echo MEMORY_STORED",
        "retrieveSuccessMarkers": [
          "MEMORY_RETRIEVED"
        ],
        "storeSuccessMarkers": [
          "MEMORY_STORED"
        ],
        "retrieveArtifacts": [
          ".scheduler-memory/latest/daily/retrieve.ok"
        ],
        "storeArtifacts": [
          ".scheduler-memory/latest/daily/store.ok"
        ]
      },
      "weekly": {
        "mode": "required",
        "retrieveCommand": "set -euo pipefail; node --input-type=module -e \"import { ingestEvents, getRelevantMemories } from './src/services/memory/index.js'; import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'; const fallbackCadence='weekly'; const cadence=process.env.SCHEDULER_CADENCE || fallbackCadence; const agentId=process.env.SCHEDULER_AGENT || ('scheduler-memory-' + cadence); const promptPath=process.env.SCHEDULER_PROMPT_PATH || ''; const runId=(process.env.SCHEDULER_RUN_ID || process.env.SCHEDULER_SESSION_ID || process.env.RUN_ID || ('session-' + Date.now().toString(36))); const promptRaw=promptPath ? readFileSync(promptPath, 'utf8') : ''; const promptLines=promptRaw.split(/\\r?\\n/).map((line)=>line.trim()).filter(Boolean); const promptIntent=promptLines.find((line)=>line.startsWith('#') || line.toLowerCase().startsWith('goal')) || promptLines[0] || 'scheduler memory retrieval'; const query=['scheduler', cadence, 'agent', agentId, 'intent', promptIntent.replace(/^#+\\s*/, '')].join(' | '); const timestamp=Date.now(); const events=[{ agent_id: agentId, content: 'Memory retrieval seed for ' + cadence + ' :: ' + promptIntent, timestamp, tags:['scheduler', cadence, 'retrieve'], metadata:{ session_id:runId, source:'scheduler-retrieve', importance:0.4, prompt_path:promptPath } }]; const ingested=await ingestEvents(events,{ agent_id: agentId }); const retrieved=await getRelevantMemories({ agent_id: agentId, query, k: 5 }); const sessionDir='.scheduler-memory/' + runId; const latestDir='.scheduler-memory/latest/' + cadence; mkdirSync(sessionDir,{ recursive:true }); mkdirSync(latestDir,{ recursive:true }); const artifact={ cadence, operation:'retrieve', runId, servicePath:'src/services/memory/index.js#getRelevantMemories', inputs:{ agentId, promptPath, promptIntent, query, events:events.length }, outputs:{ ingestedCount:ingested.length, retrievedCount:retrieved.length }, status:'ok' }; writeFileSync(sessionDir + '/retrieve.json', JSON.stringify(artifact, null, 2)); writeFileSync(sessionDir + '/retrieve.ok', 'MEMORY_RETRIEVED\\n'); writeFileSync(latestDir + '/retrieve.ok', 'MEMORY_RETRIEVED\\n');\"; echo MEMORY_RETRIEVED",
        "storeCommand": "set -euo pipefail; node --input-type=module -e \"import { ingestEvents } from './src/services/memory/index.js'; import { mkdirSync, readFileSync, writeFileSync } from 'node:fs'; const fallbackCadence='weekly'; const cadence=process.env.SCHEDULER_CADENCE || fallbackCadence; const agentId=process.env.SCHEDULER_AGENT || ('scheduler-memory-' + cadence); const promptPath=process.env.SCHEDULER_PROMPT_PATH || ''; const runId=(process.env.SCHEDULER_RUN_ID || process.env.SCHEDULER_SESSION_ID || process.env.RUN_ID || ('session-' + Date.now().toString(36))); const promptRaw=promptPath ? readFileSync(promptPath, 'utf8') : ''; const promptLines=promptRaw.split(/\\r?\\n/).map((line)=>line.trim()).filter(Boolean); const promptIntent=promptLines.find((line)=>line.startsWith('#') || line.toLowerCase().startsWith('goal')) || promptLines[0] || 'scheduler memory store'; const baseTs=Date.now(); const events=[{ agent_id: agentId, content: 'Store memory event A for ' + cadence + ' :: ' + promptIntent, timestamp: baseTs, tags:['scheduler', cadence, 'store'], metadata:{ session_id:runId, source:'scheduler-store', importance:0.55, prompt_path:promptPath } },{ agent_id: agentId, content: 'Store memory event B for ' + cadence + ' :: ' + promptIntent, timestamp: baseTs + 1, tags:['scheduler', cadence, 'store'], metadata:{ session_id:runId, source:'scheduler-store', importance:0.55, prompt_path:promptPath } }]; const stored=await ingestEvents(events,{ agent_id: agentId }); const sessionDir='.scheduler-memory/' + runId; const latestDir='.scheduler-memory/latest/' + cadence; mkdirSync(sessionDir,{ recursive:true }); mkdirSync(latestDir,{ recursive:true }); const artifact={ cadence, operation:'store', runId, servicePath:'src/services/memory/index.js#ingestEvents', inputs:{ agentId, promptPath, promptIntent, events:events.length }, outputs:{ storedCount:stored.length, summaries:stored.map((m)=>m.summary) }, status:'ok' }; writeFileSync(sessionDir + '/store.json', JSON.stringify(artifact, null, 2)); writeFileSync(sessionDir + '/store.ok', 'MEMORY_STORED\\n'); writeFileSync(latestDir + '/store.ok', 'MEMORY_STORED\\n');\"; echo MEMORY_STORED",
        "retrieveSuccessMarkers": [
          "MEMORY_RETRIEVED"
        ],
        "storeSuccessMarkers": [
          "MEMORY_STORED"
        ],
        "retrieveArtifacts": [
          ".scheduler-memory/latest/weekly/retrieve.ok"
        ],
        "storeArtifacts": [
          ".scheduler-memory/latest/weekly/store.ok"
        ]
      }
    }
  }
}
